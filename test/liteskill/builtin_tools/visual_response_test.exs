defmodule Liteskill.BuiltinTools.VisualResponseTest do
  use ExUnit.Case, async: true

  alias Liteskill.BuiltinTools.VisualResponse

  test "id/0 returns visual" do
    assert VisualResponse.id() == "visual"
  end

  test "name/0 returns Visual Responses" do
    assert VisualResponse.name() == "Visual Responses"
  end

  test "description/0 returns a string" do
    assert is_binary(VisualResponse.description())
  end

  test "list_tools/0 returns a single tool definition" do
    tools = VisualResponse.list_tools()
    assert length(tools) == 1

    [tool] = tools
    assert tool["name"] == "visual__get_catalog"
    assert is_binary(tool["description"])
    assert tool["inputSchema"]["type"] == "object"
    # No required params â€” the tool just returns the full catalog
    assert tool["inputSchema"]["required"] == []
  end

  describe "call_tool/3" do
    test "returns the generated catalog prompt" do
      {:ok, result} = VisualResponse.call_tool("visual__get_catalog", %{}, [])
      text = extract_text(result)

      # The prompt is generated by catalog.prompt() from the JS catalog
      assert text =~ "AVAILABLE COMPONENTS"
      assert text =~ "Card"
      assert text =~ "Metric"
      assert text =~ "Table"
      assert text =~ "BarChart"
      assert text =~ "LineChart"
      assert text =~ "PieChart"
      assert text =~ "Grid"
      assert text =~ "Stack"
    end

    test "prompt includes output format instructions" do
      {:ok, result} = VisualResponse.call_tool("visual__get_catalog", %{}, [])
      text = extract_text(result)

      # Should have the spec fence format instructions from the library
      assert text =~ "spec"
      assert text =~ "JSONL"
      assert text =~ "JSON Patch"
    end

    test "prompt includes rules" do
      {:ok, result} = VisualResponse.call_tool("visual__get_catalog", %{}, [])
      text = extract_text(result)

      assert text =~ "RULES"
    end

    test "prompt includes custom rules for inline chat display" do
      {:ok, result} = VisualResponse.call_tool("visual__get_catalog", %{}, [])
      text = extract_text(result)

      # Our custom rules from generate_prompt.js
      assert text =~ "viewport"
      assert text =~ "inline"
    end

    test "prompt includes state management instructions" do
      {:ok, result} = VisualResponse.call_tool("visual__get_catalog", %{}, [])
      text = extract_text(result)

      assert text =~ "$state"
      assert text =~ "INITIAL STATE"
    end

    test "prompt includes visibility condition docs" do
      {:ok, result} = VisualResponse.call_tool("visual__get_catalog", %{}, [])
      text = extract_text(result)

      assert text =~ "VISIBILITY"
    end

    test "prompt includes dynamic props docs" do
      {:ok, result} = VisualResponse.call_tool("visual__get_catalog", %{}, [])
      text = extract_text(result)

      assert text =~ "DYNAMIC PROPS"
      assert text =~ "$bindState"
      assert text =~ "$cond"
    end

    test "accepts any input params (ignores them)" do
      assert {:ok, _} =
               VisualResponse.call_tool(
                 "visual__get_catalog",
                 %{"extra" => "ignored"},
                 []
               )
    end

    test "context is not required" do
      assert {:ok, _} = VisualResponse.call_tool("visual__get_catalog", %{}, [])
    end

    test "returns error for unknown tool name" do
      {:ok, result} = VisualResponse.call_tool("visual__unknown", %{}, [])
      data = decode_content(result)
      assert data["error"] =~ "Unknown tool"
    end
  end

  # Built-in tools wrap results in the MCP content format
  defp extract_text(%{"content" => [%{"text" => text}]}), do: text

  defp decode_content(%{"content" => [%{"text" => json}]}) do
    Jason.decode!(json)
  end
end
